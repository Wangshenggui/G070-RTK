#include "4gmodule.h"
#include <string.h>


#include "FreeRTOS.h"
#include "task.h"
#include "main.h"
#include "cmsis_os.h"

USART2_RxStructure USART2_RxStruct;

//判断返回信息标志\
1：OK\
2：+GSTATE:6001\
3：
uint8_t ReturnFlag=0;

extern //判断是内部发送还是通过G431接收的
uint8_t InsideOrOutside;

//4G模块配置信息标志\
0:\
1:开始配置\
2:配置成功\
3:信息错误
uint8_t ConfigurationFlag=0;

void USART2_IDLE_Handler(void)
{
    if (RESET != __HAL_UART_GET_FLAG(&huart2, UART_FLAG_IDLE))   //判断是否是空闲中断
    {
        UBaseType_t status_value = taskENTER_CRITICAL_FROM_ISR();
        __HAL_UART_CLEAR_IDLEFLAG(&huart2);                     //清除空闲中断标志（否则会一直不断进入中断）
        HAL_UART_DMAStop(&huart2);

        ///////////////////////
        USART2_RxStruct.Rx_len = Rx_LENG - __HAL_DMA_GET_COUNTER(&hdma_usart2_rx);

        //复制到缓冲区
        memcpy(USART2_RxStruct.Buff, USART2_RxStruct.Rx_Buff, USART2_RxStruct.Rx_len);

        
        //4G模块接收信息
        if(USART2_RxStruct.Buff[0]=='O' && USART2_RxStruct.Buff[1]=='K')
        {
            ReturnFlag=1;
            //释放信号量
            ReleaseBinarySemaphore(BinarySemaphore.Module4G_RxBinarySemHandle);
        }
        //配置返回
        else if(USART2_RxStruct.Buff[USART2_RxStruct.Rx_len-9]=='1' 
            && USART2_RxStruct.Buff[USART2_RxStruct.Rx_len-7]=='0')
        {
            //从外部接收到
            if(InsideOrOutside==1)
            {
                ReturnFlag=4;
            }
            else
            {
                //配置成功
                ReturnFlag=2;
            }
            
            //释放信号量
            ReleaseBinarySemaphore(BinarySemaphore.Module4G_RxBinarySemHandle);
        }
        else if(USART2_RxStruct.Buff[USART2_RxStruct.Rx_len-9]=='0' 
            && USART2_RxStruct.Buff[USART2_RxStruct.Rx_len-7]=='0')
        {
            //配置失败
            ReturnFlag=3;
            //释放信号量
            ReleaseBinarySemaphore(BinarySemaphore.Module4G_RxBinarySemHandle);
        }
        else if(USART2_RxStruct.Buff[0]=='+')
        {
            ReturnFlag=4;
            //释放信号量
            ReleaseBinarySemaphore(BinarySemaphore.Module4G_RxBinarySemHandle);
        }
        //$CORS,STAR\r\n
        else if(USART2_RxStruct.Buff[0]=='$' && USART2_RxStruct.Buff[6]=='S' && USART2_RxStruct.Buff[7]=='T')
        {
            ConfigurationFlag = 1;
        }
        //$CORS,OK\r\n
        else if(USART2_RxStruct.Buff[0]=='$' && USART2_RxStruct.Buff[6]=='O' && USART2_RxStruct.Buff[7]=='K')
        {
            ConfigurationFlag = 2;
        }
        //$CORS,ERRORpassword\r\n
        else if(USART2_RxStruct.Buff[0]=='$' && USART2_RxStruct.Buff[6]=='E' && USART2_RxStruct.Buff[7]=='R')
        {
            ConfigurationFlag = 3;
        }
        //接收控制指令
        else if(USART2_RxStruct.Buff[0]==0xeb && USART2_RxStruct.Buff[USART2_RxStruct.Rx_len - 1]==0x90)
        {
            //释放信号量
            ReleaseBinarySemaphore(BinarySemaphore.Module4GControlBinarySemHandle);
        }
        
        
        
        HAL_GPIO_TogglePin(Module4G_LED_GPIO_Port,Module4G_LED_Pin);
        
        HAL_UART_Receive_DMA(&huart2, USART2_RxStruct.Rx_Buff, 200);           //重启开始DMA传输

        taskEXIT_CRITICAL_FROM_ISR(status_value);
    }
}















